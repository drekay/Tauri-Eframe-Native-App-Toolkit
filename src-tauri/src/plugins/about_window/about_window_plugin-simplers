use crossbeam_channel::Sender;
use tauri::{
    plugin::{Builder, TauriPlugin},
    Runtime, Manager,
};
use serde::{Serialize, Deserialize};
use std::sync::{Mutex, Arc};

// Define the plugin's state
pub struct AboutWindowState {
    pub windows: Vec<WindowInfo>,
    pub about_counter: usize,
    pub expanded_height: f32,
    pub collapsed_height: f32,
    pub gap_height: f32,
    pub dragged_window: Option<DraggedWindow>,
    pub sender: Sender<Message>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct WindowInfo {
    pub id: usize,
    pub title: String,
    pub content: String,
    pub size: (f32, f32),
    pub collapsed: bool,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct DraggedWindow {
    pub index: usize,
    pub start_pos: (f32, f32),
    pub current_pos: (f32, f32),
}

#[derive(Clone, Serialize, Deserialize)]
pub enum Message {
    AddWindow,
    CollapseWindow(usize),
    DragWindowStart(usize, (f32, f32)),
    DragWindowMove((f32, f32)),
    DragWindowEnd,
}

// Plugin command handlers
#[tauri::command]
pub fn send_message(message: Message, state: tauri::State<'_, Arc<Mutex<AboutWindowState>>>) -> Result<(), String> {
    let state = state.lock().map_err(|_| "Failed to lock state".to_string())?;
    println!("window send message");
    state.sender.send(message).map_err(|_| "Failed to send message".to_string())
}

// Function to create and initialize the plugin
pub fn init<R: Runtime>() -> TauriPlugin<R> {
    println!("window- initialize the plugin");
    Builder::new("about_window")
        .setup(|app, _api| {
            // The state is now managed in the main.rs file
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![send_message])
        .build()
}

 